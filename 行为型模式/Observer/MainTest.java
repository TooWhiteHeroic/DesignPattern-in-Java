package Observer;

public class MainTest {
    //观察者模式
    /**
     * 观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
     * 这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。
     *
     * 结构
     * 1.ISubject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象
     * 2.Subject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知
     * 3.IObserver：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己
     * 4.Observer：具体观察者，是实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态
     *
     * 应用场景
     * 1.关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系
     * 2.事件多级触发场景
     * 3.跨系统的消息交换场景，如消息队列、事件总线的处理机制
     *
     * 优点
     * 解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换
     *
     * 缺点
     * 在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，
     * 而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现
     */
    public static void main(String[] args) {
        Observer g1 = new Observer("老王");
        Observer g2 = new Observer("老黄");
        Observer g3 = new Observer("老张");

        Subject wnm = new Subject("王尼玛");
        wnm.attach(g1);
        Subject mxt = new Subject("马小跳");
        mxt.attach(g2);
        Subject fsd = new Subject("房涉毒");
        fsd.attach(g3);
        mxt.gossip("公然当街如厕，人神共愤啊！");
        wnm.gossip("与当红一线女明星私会高档会所");
        fsd.gossip("一心悔过剃度出家啦");

    }
}
